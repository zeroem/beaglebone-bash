#!/bin/bash -e

function help_text() {
  cat <<HELP
Manage GPIO pins on the BeagleBone Black

Available subcommands are:
  export
  unexport
  high
  low
HELP
}

function gpio_pin_path() {
  printf "%s/gpio%d\n" "${GPIO_PIN_PATH_PREFIX:-/sys/class/gpio}" "${1:?Pin number is a required argument}"
}

function debug() {
  if [ -n "$debug" ]; then
    printf "%s\n" "$*" >&2
  fi
}

function gpio_pin() {
  local -r header="$1"
  local -r -i pin="$2"
  local -r header_dir="$base_dir"/pins/"$header"
  local -r pin_dir="$header_dir"/"$pin"

  debug "header_dir: $header_dir"
  debug "pin_dir: $pin_dir"

  if [ ! -d  "$header_dir" ]; then
    printf "'%s' is not a valid header.\n" "$header" >&2
    exit 1
  fi

  if [ ! -d "$pin_dir" ]; then
    printf "'%d' is not a valid pin on header '%s'" "$pin" "$header" >&2
    exit 1
  fi

  if [ ! -f "$pin_dir"/gpio ]; then
    printf "%s %d is not a GPIO pin\n" "$header" "$pin" >&2
    printf "fail"
    exit 1
  fi

  cat "$pin_dir"/gpio
}

function export_help_text() {
  cat <<HELP
Export GPIO pins

Usage

$(basename "$0") export [OPTIONS] HEADER PIN_NO

Options:
  --high          Initializes the pin high, implies --out
  -i, --in        Set the pin direction to in
  --low           Initializes the pin to low, implies --out
  -o, --out       Set the pin direction to out

HELP
}

function unexport_help_text() {
  cat <<HELP
Unexport GPIO pins

Usage

$(basename "$0") unexport [OPTIONS] HEADER PIN_NO

Options:

HELP
}

function gpio_high() {
  true
}

function one_direction() {
  local -r current="${1}"
  local -r desired="${2}"

  if [ "$current" == "in" ] && [ "$desired" != "in" ]; then
    printf "You cannot set the direction to '%s' after already setting it to '%s'.\n" "$desired" "$current" >&2
    return 1
  else
    if [ -z "$current" ] || [ "$current" == "out" ]; then
      printf "%s\n" "$desired"
    else
      printf "%s\n" "$current"
    fi
  fi
}


function gpio_export() {
  local arg
  local -a pin_info=()

  while [ $# -gt 0 ]; do
    arg="$1"
    shift

    case "$arg" in
      --debug|--no-debug)
        ;;
      --high)
        local direction="$(one_direction "$direction" high)"
        debug "direction is now '${direction}'"
        ;;
      -i|--in)
        local direction="$(one_direction "$direction" in)"
        debug "direction is now '${direction}'"
        ;;
      --low)
        local direction="$(one_direction "$direction" low)"
        debug "direction is now '${direction}'"
        ;;
      -o|--out)
        local direction="$(one_direction "$direction" out)"
        debug "direction is now '${direction}'"
        ;;
      *)
        pin_info+=("$arg")
        ;;
    esac
  done

  validate_pin_info "${pin_info[@]}"

  local -r header="${pin_info[0]}"
  local -r pin="${pin_info[1]}"
  local -r -i gpio_pin="$(gpio_pin "$header" "$pin")"
  local -r gpio_pin_path="$(gpio_pin_path "$gpio_pin")"

  if [ ! -e "$gpio_pin_path" ]; then
    debug "Exporting ${header} ${pin} as GPIO pin ${gpio_pin}."
    printf "%d" "$gpio_pin" > "$export_path"
  else
    debug "${header} ${pin} is already exported as GPIO pin ${gpio_pin}."
  fi

  if [ -n "$direction" ]; then
    debug "Initializing direction to '${direction}'"
    printf "$direction" > "$gpio_pin_path"/direction
  fi
}

function gpio_unexport() {
  local arg
  local -a pin_info=()

  while [ $# -gt 0 ]; do
    arg="$1"
    shift

    case "$arg" in
      --debug|--no-debug)
        ;;
      *)
        pin_info+=("$arg")
        ;;
    esac
  done

  validate_pin_info "${pin_info[@]}"

  local -r header="${pin_info[0]}"
  local -r pin="${pin_info[1]}"
  local -r -i gpio_pin="$(gpio_pin "$header" "$pin")"
  local -r gpio_pin_path="$(gpio_pin_path "$gpio_pin")"

  if [ -e "$gpio_pin_path" ]; then
    debug "Unexporting ${header} ${pin} as GPIO pin ${gpio_pin}."
    printf "%d" "$gpio_pin" > "$unexport_path"
  else
    debug "${header} ${pin} is not exported as GPIO pin ${gpio_pin}."
  fi
}

function gpio_high() {
  local arg
  local -a pin_info=()

  while [ $# -gt 0 ]; do
    arg="$1"
    shift

    case "$arg" in
      --debug|--no-debug)
        ;;
      *)
        pin_info+=("$arg")
        ;;
    esac
  done

  local -r header="${pin_info[0]}"
  local -r pin="${pin_info[1]}"
  local -r -i gpio_pin="$(gpio_pin "$header" "$pin")"
  local -r gpio_pin_path="$(gpio_pin_path "$gpio_pin")"

  if [ -e "$gpio_pin_path" ]; then
    debug "Setting ${header} ${pin} as GPIO pin ${gpio_pin} HIGH."
    printf "1" > "$gpio_pin_path"/value
  else
    debug "${header} ${pin}, GPIO pin ${gpio_pin}, is not exported."
    return 1
  fi
}

function gpio_low() {
  local arg
  local -a pin_info=()

  while [ $# -gt 0 ]; do
    arg="$1"
    shift

    case "$arg" in
      --debug|--no-debug)
        ;;
      *)
        pin_info+=("$arg")
        ;;
    esac
  done

  local -r header="${pin_info[0]}"
  local -r pin="${pin_info[1]}"
  local -r -i gpio_pin="$(gpio_pin "$header" "$pin")"
  local -r gpio_pin_path="$(gpio_pin_path "$gpio_pin")"

  if [ -e "$gpio_pin_path" ]; then
    debug "Setting ${header} ${pin} as GPIO pin ${gpio_pin} LOW."
    printf "0" > "$gpio_pin_path"/value
  else
    debug "${header} ${pin}, GPIO pin ${gpio_pin}, is not exported."
    return 1
  fi
}

function validate_pin_info() {
  if [ $# -eq 0 ]; then
    printf "Both HEADER and PIN_NO are required arguments.\n\n" >&2
    help_text
    return 1
  elif [ $# -eq 1 ]; then
    printf "PIN_NO is required argument.\n\n" >&2
    help_text
    return 1
  elif [ $# -gt 2 ]; then
    printf "Too many arguments passed, expected 2 but got %d.\n\n" "$#"
    help_text
    return 1
  fi
}

function main() {
  local -r base_dir="$(cd "$(dirname "$0")"/..; pwd)"
  local -r export_path="${GPIO_EXPORT_PATH:-/sys/class/gpio/export}"
  local -r unexport_path="${GPIO_UNEXPORT_PATH:-/sys/class/gpio/unexport}"

  local -r subcommand="gpio_${1}"

  local -a args=("$@")

  while [ "${#args[@]}" -gt 0 ]; do
    arg="${args[0]}"
    args=("${args[@]:1}")

    case "$arg" in
      --debug)
        local debug=yes
        ;;
      --no-debug)
        local debug=""
        ;;
    esac
  done

  if [ "$1" == "-h" ] || [ "$1" == "--help" ] || [ "$1" == "help" ] || [ -z "$1" ]; then
    if [ -z "$2" ]; then
      help_text
      exit 0
    elif local -f -F "$2"_help_text &> /dev/null; then
      "$2"_help_text
      exit 0
    else
      printf "'%s' is not a valid subcommand.\n" "$2"
    fi
  fi

  if local -f -F "$subcommand" &> /dev/null; then
    "$subcommand" "${@:2}"
  fi
}

main $@
